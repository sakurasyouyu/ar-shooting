<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR Advanced Shooter</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Helvetica Neue', sans-serif; touch-action: none; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        #header {
            padding: 20px; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            display: flex; justify-content: space-between; align-items: center;
        }
        .status-box { color: white; font-weight: bold; text-shadow: 0 0 5px black; }
        #score-display { font-size: 24px; color: #00ffcc; }
        #hp-container { width: 150px; height: 20px; background: #333; border: 2px solid white; border-radius: 10px; overflow: hidden; }
        #hp-bar { width: 100%; height: 100%; background: #00ff00; transition: width 0.3s, background 0.3s; }
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s;
        }
        #message-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; z-index: 20;
        }
        h1 { margin: 0 0 10px 0; color: #00ffcc; text-transform: uppercase; }
        p { margin: 0 0 20px 0; color: #ccc; text-align: center; line-height: 1.5; }
        button {
            background: #00ffcc; border: none; padding: 15px 40px;
            font-size: 20px; border-radius: 30px; cursor: pointer;
            color: #000; font-weight: bold; box-shadow: 0 0 15px #00ffcc;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        #cam-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: -1;
        }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    
    <div id="ui-layer">
        <div id="header">
            <div class="status-box">HP <div id="hp-container"><div id="hp-bar"></div></div></div>
            <div class="status-box">SCORE: <span id="score-display">0</span></div>
        </div>
    </div>

    <div id="message-screen">
        <h1>AR Battle</h1>
        <p>360度から迫る敵を撃ち落とせ！<br>敵の攻撃を受けるとHPが減ります。</p>
        <button id="start-btn">MISSION START</button>
    </div>

    <video id="cam-video" autoplay muted playsinline></video>

    <a-scene vr-mode-ui="enabled: false" embedded renderer="alpha: true; antialias: true">
        <a-assets>
            <a-asset-item id="enemy-model-glb" src="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb"></a-asset-item>
        </a-assets>

        <a-entity id="camera-rig" position="0 0 0">
            <a-camera id="player-camera" position="0 1.6 0" look-controls="enabled: true" wasd-controls="enabled: false">
                <a-entity 
                    cursor="fuse: false"
                    position="0 0 -1"
                    geometry="primitive: ring; radiusInner: 0.02; radiusOuter: 0.03"
                    material="color: #00ffcc; shader: flat; opacity: 0.8"
                    animation__click="property: scale; startEvents: click; from: 0.5 0.5 0.5; to: 1 1 1; dur: 150"
                    raycaster="objects: .clickable">
                </a-entity>
            </a-camera>
        </a-entity>

        <a-light type="ambient" color="#888"></a-light>
        <a-light type="directional" position="-1 2 1" intensity="1.5"></a-light>

        <a-entity id="game-world"></a-entity>
    </a-scene>

    <script>
        // サウンド機能
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const SoundFX = {
            playTone: (freq, type, duration) => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + duration);
            },
            shoot: () => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            },
            explosion: () => { SoundFX.playTone(100, 'sawtooth', 0.3); },
            damage: () => { SoundFX.playTone(150, 'square', 0.2); setTimeout(()=> SoundFX.playTone(100, 'square', 0.2), 50); }
        };

        // --- 設定 (調整箇所) ---
        const CONFIG = {
            maxHP: 100,
            enemySpawnRate: 1000, // 変更: 1000ms (1秒)ごとに敵が出現（以前は3000ms）
            maxEnemies: 20,       // 変更: 画面上の最大敵数を20体に増加（以前は8体）
            enemyShootRate: 2500,
        };

        let state = { hp: CONFIG.maxHP, score: 0, isPlaying: false, enemies: [] };

        const els = {
            score: document.getElementById('score-display'),
            hpBar: document.getElementById('hp-bar'),
            damageOverlay: document.getElementById('damage-overlay'),
            world: document.getElementById('game-world'),
            messageScreen: document.getElementById('message-screen'),
            msgTitle: document.querySelector('#message-screen h1'),
            msgText: document.querySelector('#message-screen p'),
            startBtn: document.getElementById('start-btn'),
            video: document.getElementById('cam-video')
        };

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
                els.video.srcObject = stream;
            } catch (e) { console.warn("Camera error:", e); }
        }

        function spawnEnemy() {
            if (!state.isPlaying) return;

            const enemy = document.createElement('a-entity');
            enemy.setAttribute('class', 'clickable enemy');
            enemy.setAttribute('gltf-model', '#enemy-model-glb');
            enemy.setAttribute('scale', '0.5 0.5 0.5');

            // 出現位置の調整: プレイヤーから4〜8メートルの位置に見やすく配置
            const r = 4 + Math.random() * 4; 
            const theta = Math.random() * 360;
            const phi = Math.random() * 60 - 20; // -20度〜+40度
            
            const x = r * Math.cos(theta * Math.PI / 180);
            const y = r * Math.sin(phi * Math.PI / 180) + 1.6;
            const z = r * Math.sin(theta * Math.PI / 180);

            enemy.setAttribute('position', `${x} ${y} ${z}`);
            enemy.setAttribute('look-at', '[camera]');
            enemy.setAttribute('animation', `property: position; to: ${x} ${y + 0.5} ${z}; dir: alternate; dur: 2000; loop: true`);

            enemy.addEventListener('click', () => destroyEnemy(enemy));

            const shootInterval = setInterval(() => {
                if(!state.isPlaying || !enemy.parentNode) { clearInterval(shootInterval); return; }
                enemyShoot(enemy);
            }, CONFIG.enemyShootRate + Math.random() * 1000);

            els.world.appendChild(enemy);
            state.enemies.push(enemy);
        }

        function destroyEnemy(enemy) {
            SoundFX.explosion();
            enemy.removeAttribute('animation');
            enemy.setAttribute('animation__die', 'property: scale; to: 0 0 0; dur: 200; easing: easeInQuad');
            state.score += 100;
            els.score.innerText = state.score;
            setTimeout(() => { if(enemy.parentNode) enemy.parentNode.removeChild(enemy); }, 200);
        }

        function enemyShoot(enemyEl) {
            const pos = enemyEl.getAttribute('position');
            const bullet = document.createElement('a-entity');
            bullet.setAttribute('geometry', 'primitive: sphere; radius: 0.1');
            bullet.setAttribute('material', 'color: red; emissive: #ff0000; emissiveIntensity: 1');
            bullet.setAttribute('position', pos);
            bullet.setAttribute('animation', `property: position; to: 0 1.6 0; dur: 1500; easing: linear`);

            const checkHit = setInterval(() => {
                if(!state.isPlaying) { clearInterval(checkHit); return; }
                const bPos = bullet.getAttribute('position');
                const dist = Math.sqrt(bPos.x**2 + (bPos.y-1.6)**2 + bPos.z**2);
                if (dist < 0.5) {
                    clearInterval(checkHit);
                    if(bullet.parentNode) bullet.parentNode.removeChild(bullet);
                    takeDamage();
                }
            }, 100);

            setTimeout(() => { clearInterval(checkHit); if(bullet.parentNode) bullet.parentNode.removeChild(bullet); }, 1600);
            els.world.appendChild(bullet);
        }

        function takeDamage() {
            SoundFX.damage();
            state.hp -= 20;
            updateHPUI();
            els.damageOverlay.style.opacity = 0.5;
            setTimeout(() => els.damageOverlay.style.opacity = 0, 200);
            if (state.hp <= 0) gameOver();
        }

        function updateHPUI() {
            const pct = Math.max(0, (state.hp / CONFIG.maxHP) * 100);
            els.hpBar.style.width = `${pct}%`;
            els.hpBar.style.background = pct < 30 ? 'red' : '#00ff00';
        }

        function startGame() {
            state.score = 0;
            state.hp = CONFIG.maxHP;
            state.isPlaying = true;
            els.score.innerText = "0";
            updateHPUI();
            els.world.innerHTML = '';
            els.messageScreen.style.display = 'none';
            startCamera();
            
            // 変更: 初期スポーン数を10体に増加
            for(let i=0; i<10; i++) spawnEnemy();

            const gameLoop = setInterval(() => {
                if(!state.isPlaying) { clearInterval(gameLoop); return; }
                // 変更: 最大数をCONFIG.maxEnemiesでチェック
                if(document.querySelectorAll('.enemy').length < CONFIG.maxEnemies) {
                    spawnEnemy();
                }
            }, CONFIG.enemySpawnRate);
        }

        function gameOver() {
            state.isPlaying = false;
            els.msgTitle.innerText = "GAME OVER";
            els.msgText.innerHTML = `SCORE: ${state.score}<br>人類は敗北した...`;
            els.startBtn.innerText = "RETRY";
            els.messageScreen.style.display = 'flex';
        }

        els.startBtn.addEventListener('click', () => {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            SoundFX.shoot();
            startGame();
        });

        document.body.addEventListener('click', (e) => {
            if(!state.isPlaying || e.target === els.startBtn) return;
            SoundFX.shoot();
        });
    </script>
</body>
</html>
